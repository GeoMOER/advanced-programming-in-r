```{r knitsetup, echo=FALSE, results='hide', warning=FALSE, message=FALSE, cache=FALSE}
library(knitr)
library(knitcitations)
opts_knit$set(base.dir='./', fig.path='', out.format='md')
opts_chunk$set(comment='', results='markup')
# See yihui.name/knitr/options for more Knitr options.
##### Put other setup R code here
library(ggplot2)

# end setup chunk
```
# Summarizing data

The **dplyr** package is a marvelous and very intuitive set of tools to perform 
fast and easy data manipulation and summarization in preparation e.g. for 
visualization. In the following, we'll guide you through a selection of 
operations you may find helpful within the course of future R workflows on the 
basis of the 'diamonds' dataset. Based on a very comprehensive 
[RPubs tutorial](https://rpubs.com/justmarkham/dplyr-tutorial), these include

* `filter`, 
* `select`, 
* `arrange`, 
* `mutate` and 
* `summarise` (incl. `group_by`) 

each of which will be accompanied by an equivalent base-R approach.

### A brief note on `tbl_df`
You probably noticed earlier that 'diamonds' consists of a rather large number 
of observations. 

```{r diamonds_dim}
## number of columns and rows of 'diamonds'
dim(diamonds)
```

Unless you are willing to stumble into truncated console output when typing 
`diamonds` (please don't do that), you are inevitably required to perform 
`head(diamonds)` or `str(diamonds)` in order to get an impression of the data 
you are dealing with. Along with **dplyr** comes a function called `tbl_df` that 
helps to overcome such ritual-like investigation procedures. 

```{r tbl_df}
## required package
library(dplyr)

## create a local data frame
diamonds <- tbl_df(diamonds)
diamonds
```

Notice that not only the class and the dimensions of the dataset are displayed, 
but also the variable types of the single columns. Furthermore, the console 
output is truncated after the first 10 rows (which would also apply to the 
displayed columns if we were dealing with a somewhat wider dataset). Practically, 
this means that the appropriate use of `tbl_df` lets you kill two birds with one 
stone compared with the 2-step approach via `head` and `str` shown above. 

### Subsetting data via `filter`
Just like base-R `subset` or simply indexing via conditional expressions 
included in square brackets, `filter` creates a subset of your data based on 
some user-defined criteria. For the time being, let's have a look at your 
subsetting abilities.

#### Task #2.1.1: base-R subsetting
Suppose we want to create a subset of 'diamonds' keeping all D-, E- or F-colored 
specimen with a 'Premium' or 'Ideal' cut quality and a weight of more than 3 
carat. Try to figure out two different solutions, one <u>with</u> and one 
<u>without</u> using `subset`. 

<center>
  <img src="https://upload.wikimedia.org/wikipedia/commons/2/25/Hourglass_2.svg" alt="hourglass" style="width: 125px;"/>
</center>

```{r subset, echo = FALSE, eval = FALSE}
subset(diamonds, carat > 3 & 
         (cut == "Premium" | cut == "Ideal") & 
         (color == "D" | color == "E" | color == "F"))

subset(diamonds, carat > 3 &
         cut %in% c("Premium", "Ideal") &
         color %in% c("D", "E", "F"))

diamonds[diamonds$carat > 3 & 
           diamonds$cut %in% c("Premium", "Ideal") &
           diamonds$color %in% c("D", "E", "F"), ]
```

Using `filter` is straightforward and very similar to `subset`. The first 
argument represents the data frame, whereas any subsequent argument represents a 
logical expression to filter particular rows. Note that in contrast to the 
direct subsetting via square brackets, you are not required to repeat the name 
of the data frame with every single condition.

```{r filter}
filter(diamonds, carat > 3 &
         cut %in% c("Premium", "Ideal") &
         color %in% c("D", "E", "F"))
```

### Selecting columns via `select`
Selecting specific columns from a data frame follows a similar syntax to 
`filter` and works analogous to SQL standards. Again, the first argument 
represents the data frame under consideration followed by the desired column 
names (without double quotes). 

```{r select}
select(diamonds, carat, cut, color, clarity)
```

Note that both the use of `c` to combine the single column names into a vector 
as well as the need for double quotes became obsolete. In addition to this, 
column names may be treated analogous to numeric indices, eliminating the need 
to count columns when desiring to extract several consecutive columns from a 
rather wide datasets. 

```{r select2}
select(diamonds, carat:clarity, price)
```

There's also a set of additional helper functions, including `starts_with`, 
`ends_with`, `matches` and `contains`, which definitely go beyond the scope of 
this short introduction. Still, it's good to know that such things existed in 
case you needed any of them.

### A brief note on chaining (or pipelining)
Now suppose we wanted to select the same columns from the previously created 
subset of data. Traditionally, this would either require a 2-step approach, 
generating otherwise unnecessary intermediate results, via 

```{r filter_select, eval = FALSE}
## first, create subset
diamonds_sub <- filter(diamonds, carat > 3 &
                         cut %in% c("Premium", "Ideal") &
                         color %in% c("D", "E", "F"))

## second, select columns
select(diamonds_sub, carat:clarity, price)
```

or nested function calls which are usually hard to read.

```{r filter_select2, eval = FALSE}
## all-in-one nested solution
select(
  filter(diamonds, carat > 3 &
           cut %in% c("Premium", "Ideal") &
           color %in% c("D", "E", "F")), 
  carat:clarity, price
)
```

**dplyr** introduces the `%>%` operator which is meant to bridge a set of 
connected processing steps, thus eliminating the need for intermediary 
variables ('diamonds_sub') or nested functions. Just think of `%>%` as a "then" 
connecting two parts of a sentence.

```{r pipelining}
diamonds %>%
  filter(carat > 3 &
           cut %in% c("Premium", "Ideal") &
           color %in% c("D", "E", "F")) %>%
  select(carat:clarity, price)
```

Note that chaining comes in handy when performing multiple operations at once, 
rendering your code much more elegant and reducing the accumulated overhead 
significantly. The single worksteps can be read from left to right and from top 
to bottom, just like you would read the pages of a book. 

### Reordering data frames via `arrange`
`arrange` ensures a fast and easy rearrangement of rows based on certain 
variables. Although this can be done using base-R, its necessity soon becomes 
clear when dealing with rearrangements based on multiple variables as the **dplyr** 
approach requires far less typing.

#### Task #2.1.2: base-R rearrangement of rows
Here's a tricky one. Let's assume we wanted to rearrange the rows of a subset of 
'diamonds' (color, price, carat) according to color, with the best color (D) on 
top. Since we're also interested in a preferably low price, the diamonds of 
uniform color should be sorted according to their price, with cheapest ones on 
top. Finally, for each set of diamonds with a specified color and price, we want 
their weights arranged in descending order, with the heaviest specimen on top.

<center>
  <img src="https://upload.wikimedia.org/wikipedia/commons/2/25/Hourglass_2.svg" alt="hourglass" style="width: 125px;"/>
</center>

```{r order, echo = FALSE, eval = FALSE}
diamonds_sub <- diamonds[, c("color", "price", "carat")]
diamonds_carat <- diamonds_sub[order(diamonds_sub$carat, decreasing = TRUE), ]
diamonds_carat[order(diamonds_carat$color, diamonds_carat$price), ]
```

Again, the **dplyr** approach is much simpler and can be done in one go. 

```{r arrange}
diamonds %>%
  select(color, price, carat) %>%
  arrange(color, price, desc(carat))
```

### Add new columns via `mutate`
`mutate` lets you add new variables to an existing data frame. It is basically 
an extended version of base-R `transform` in the sense that it allows you to 
directly work with columns you've just created. 

```{r mutate}
diamonds %>%
  select(color, carat, price) %>%
  mutate(ppc = price / carat, 
         ppc_rnd = round(ppc, 2))
```

### Summarise values via `summarise`
Similar to `plyr::summarise`, the **dplyr** version of `summarise` lets you melt 
a data frame into a single row depending on the supplied function. The function 
works quite similar as base-R `aggregate`. However, the ease of use is definitely 
on the side of `summarise`. 

#### Task #2.1.3: base-R data aggregation
In order to demonstrate **dplyr**'s ease of use in terms of data summarization, 
try to `aggregate` diamonds in such a fashion that you end up with a data frame 
showing the minimum, mean and maximum price per diamond color.

<center>
  <img src="https://upload.wikimedia.org/wikipedia/commons/2/25/Hourglass_2.svg" alt="hourglass" style="width: 125px;"/>
</center>

```{r aggregate, echo = FALSE, eval = FALSE}
aggregate(diamonds$price, by = list(diamonds$color), FUN = function(x) {
  c(MIN = min(x), MEAN = mean(x), MAX = max(x))
})
```

As for the **dplyr** solution, the `group_by` function comes in handy when 
trying to calculate metrics from sub-groups of data, e.g. depending on the 
diamonds' color, rather than from the entire data frame.

```{r group_by}
diamonds %>% 
  group_by(color) %>%
  summarise(MIN = min(price), MEAN = mean(price), MAX = max(price))
```

In order to summarize an entire variable into one single value, just drop the 
`group_by` function. 

```{r summarise}
summarise(diamonds, min = min(price), mean = mean(price), max = max(price))
```

Now that you're familiar with the basics of data manipulation via **dplyr** and 
before moving on to actual data visualization via **ggplot2**, it's time to have 
a brief look at data format conversion from wide to long format which is essential 
for displaying numerous groups of data in one single plot.