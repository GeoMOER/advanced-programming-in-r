```{r knitsetup, echo=FALSE, results='hide', warning=FALSE, message=FALSE, cache=FALSE}
library(knitr)
opts_knit$set(base.dir='./', fig.path='', out.format='md')
opts_chunk$set(prompt=TRUE, comment='', results='markup')
# See yihui.name/knitr/options for more Knitr options.
##### Put other setup R code here

library(ggplot2)
# end setup chunk
```
# The *\*apply* family

You may have heard of this family of functions and may have wondered what they are all about and how they differ from classic loop structures. First of all, we need to recognize that these structures are pretty much unique to R. The reason for this is that R is at its very core a so-called _functional programming language_. This means nothing else than "every operation in R is carried out by an appropriate function". In fact, even the classical `<-` assignment operator is defined in the same way as any other function as well.

```{r assign}
a <- 3
a

"<-"(b, 15)
b

"+"(a, b)
```

You may wonder why this is relevant to understand `*apply`? 

The one thing that all `*apply` functions have in common is that they are all so-called closures that can take a function as an argument. Usually, these closures take some object and some function as input and then apply the function to every entry of the object. The difference between the various `*apply` functions is basically the type of object they are designed for and hence each of these has slightly different requirements for the structure of the supplied function.

First, let's have a look at `apply()`. It has three main arguments

* `X` a matrix (or array) - or a 'clean' data frame that can be coerced to a mtraix, i.e. no mixture of classes in the columns (see example below)
* `MARGIN` an integer specifying whether to apply the supplied function to the rows (1) or the columns (2)
* `FUN` the function to be applied

Other function related arguments such as `na.rm = ...` can also be supplied.

Let's try this

```{r apply}
data(diamonds)

## subset diamonds to only numerical columns
diamonds_num <- diamonds[, -c(2:4)]
col_means <- apply(diamonds_num, 2, mean, na.rm = TRUE)
col_means

## for rows use MARGIN = 1
row_sd <- apply(diamonds_num, 1, sd, na.rm = TRUE)
```

```{r rapply}
dat_list <- as.list(diamonds)
fun_list <- list("mean", rep("nchar", 3), rep("sd", 3), "median", "min", "var")

tst <- rapply(diamonds, f = mean, classes = "numeric")
```

The most general of all `lapply()`. It can take 