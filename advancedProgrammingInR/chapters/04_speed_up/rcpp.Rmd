---
output: 
  html_document: 
    keep_md: yes
---
```{r knitsetup, echo=FALSE, results='hide', warning=FALSE, message=FALSE, cache=FALSE}
library(knitr)
library(knitcitations)
mybib <- bibtex::read.bib("../../bib/references")
opts_knit$set(base.dir='./', fig.path='', out.format='md')
opts_chunk$set(comment='', results='markup')
options(width = 110)
# See yihui.name/knitr/options for more Knitr options.
##### Put other setup R code here


# end setup chunk
```
# C++ interconnectivity via **Rcpp**

### Prerequisites
In order for **Rcpp** to work, we have to make sure your local system is capable 
of building packages. On Linux-based systems, this shouldn't be much of a 
problem since things just generally tend to work whereas on Windows (or OS X), 
you will possible be required to install 
[**Rtools**](https://cran.r-project.org/bin/windows/Rtools/) 
(or [**Xcode**](https://itunes.apple.com/us/app/xcode/id497799835?mt=12)) to be 
able to compile C++ functions and make them available in R. Further information 
on package development prerequisites can be found 
[here](https://support.rstudio.com/hc/en-us/articles/200486498-Package-Development-Prerequisites). 

You may easily check if everything works by running the following code chunk.

```{r cpp_setup}
## load 'Rcpp' package
library(Rcpp)

## try to evaluate c++ expression
evalCpp("1 + 1")
```

If this expression does <u>not</u> evaluate to '2', there's something wrong with 
your local setup and you should possibly contact one of the lecturers for 
troubleshooting.

### How to make your C++ code available in R
**Rcpp** offers two ways to import C++ functions into R, namely

* `cppFunction` and
* `sourceCpp`. 

While the former takes an entire C++ source code as input argument (`code`), the 
latter behaves very similar to base-R `source` in the sense that it sources a 
code file (.cpp) and makes the functions included therein available in your  
global R environment. During this short overview, however, we'll primarily focus 
on the first approach while the latter is introduced only briefly.

##### No input, scalar output
No matter which approach you will use in the end, **Rcpp** will take the C++ 
code, compile it and transform it into a proper R function. Imagine, for 
instance, the following code (which is heavily based on Hadley Wickham's 
[Advanced R. High performance functions with Rcpp](http://adv-r.had.co.nz/Rcpp.html) 
tutorial). 

```{r cpp_ex1}
## function that returns '1'
cppFunction('int one() {
  return 1;
}')

one()
```

Note that C++ requires you to specify the output type of `one()` which, in this 
particular case, is obviously an integer (`int`). Accordingly, R variables of 
type 'numeric', 'character' and 'logical' are referred to as `double`, `String` 
and `bool` in C++ language. Let's move on to our next example.

##### Scalar input, scalar output
When working with C++ code, you are required to not only specify the output 
type of your function, but also the type(s) of the input argument(s). The next 
code chunk defines a function `signC` that takes an integer input `x` and, 
depending on the arithmetic sign of `x`, returns one of '1', '0' and '-1'. 

```{r cpp_ex2}
## function that returns 1 if 'x' is positive, -1 if 'x' is negative, 0 otherwise
cppFunction('int signC(int x) {
  if (x > 0) {
    return 1;
  } else if (x == 0) {
    return 0;
  } else {
    return -1;
  }
}')

signC(-10)
```

Note also that `if` statements in C++ look very similar to their R equivalent. 
The only obvious differences are 

* the need to explicitly include a `return` statement and 
* the semicolons (`;`) terminating each line of code.

##### Vector input, scalar output
Although this seems hardly necessary, let's assume for now that we wanted to 
rewrite the base-R `sum` function in C++. Rather than supplying a scalar input 
argument, we need the function to work with a vector of numbers for obvious 
reasons. Similar to the different scalar inputs depicted above, base-R 
'integer', 'numeric', 'character' and 'logical' vectors are represented as 
`IntegerVector`, `NumericVector`, `CharacterVector` and `LogicalVector` in C++. 
This time, it also makes sense to define the input type as `NumericVector` and, 
accordingly, the output type as `double` since we'd possibly like to supply 
numbers with decimal places instead of raw integers.

```{r cpp_ex3}
cppFunction('double sumC(NumericVector x) {
  int n = x.size();
  double total = 0;
  for(int i = 0; i < n; ++i) {
    total += x[i];
  }
  return total;
}')

sumC(seq(0, 1, 0.1))
```

##### Matrix input, vector output
**Rcpp** also comes with a number of so-called 'sugars' that help newcomers to 
find their way by providing C++-equivalents of a number of built-in R functions. 
A short overview of featured functions is e.g. given by 
`r citet(mybib[[grep("Eddelbuettel", mybib)]])`. Amongst others, these include 

* **math functions**, e.g. `abs`, `ceiling`, `floor`, `exp`, `log`
* **scalar summaries**, e.g. `mean`, `min`, `max`, `sum`, `sd`, `var`
* **vector summaries**, e.g. `cumsum`, `diff`
* **finding utilities**, e.g. `which_max`, `which_min`, `match`
* **finding duplicates**, e.g. `duplicated`, `unique`

In order to demonstrate the proper use of such 'sugars' and, at the same time, 
introduce `NumericMatrix` (`NumericVector`) as further input (output) variable 
types, let's replicate the previous example on the use of `apply` to calculate 
mean values from each single variable column of the 'diamonds' dataset using 
**Rcpp** functionality. For the sake of simplicity of this demonstration, let's 
again focus on the numeric columns only (note also the use of `sapply` to create 
an index vector of (non-)numeric columns). 

```{r colMeansC, message = FALSE}
## subset with numeric columns only
library(ggplot2)

num_cols <- sapply(1:ncol(diamonds), function(i) is.numeric(diamonds[, i]))
diamonds_sub <- as.matrix(diamonds[, num_cols])

## c++-version of 'colMeans'
cppFunction("NumericVector colMeansC(NumericMatrix x) {
  
  // number of rows and columns
  int nCol = x.ncol();
  int nRow = x.nrow();
  
  // temporary variable of size nrow(x) to store column values in
  NumericVector nVal(nRow);
  
  // initialize output vector
  NumericVector out(nCol);
  
  // loop over each column
  for (int i = 0; i < nCol; i++) {
    
    // values in current column
    nVal = x(_, i);
    
    // store mean of current 'nVal' in 'out[i]'
    out[i] = mean(nVal);
  }
  
  return out;
}")

means <- colMeansC(diamonds_sub)
names(means) <- colnames(diamonds_sub)
means

## speed check
library(microbenchmark)

microbenchmark(
  val_apply <- apply(diamonds_sub, 2, mean), 
  val_cpp <- colMeansC(diamonds_sub)
, times = 20L)

## similarity check
identical(val_apply, means)
```

It's milliseconds we are talking about here, but still - `colMeansC` runs 
more than 5 times faster as compared to the `apply` approach!

### What's the point of that?
You might guess that we did not decide to include this chapter on C++ 
interconnectivity just for fun. The actual reason is that C++ code performs much 
faster as compared to R when it comes to `for` loops. Without going too much 
into detail, one of the underlying reason is the very efficient memory 
management of the C++ language as compared to the massive overhead that R 
produces during each intermediary step. But find out for yourselves...

##### Task 4.2: `sumR` vs. `sumC`
Write a function `sumR` (do <u>not</u> use the built-in `sum` function) as an 
equivalent to the above `sumC` function and have a look at the time it takes to 
run `sumR(1:1e6)` using `system.time` (or `microbenchmark`). 

<center>
  <img src="https://upload.wikimedia.org/wikipedia/commons/2/25/Hourglass_2.svg" alt="hourglass" style="width: 125px;"/>
</center>

```{r sumR, echo = FALSE}
sumR <- function(x) {
  
  ## initialize input and output vector
  out <- 0
  
  ## add up values of 'x'
  for (i in 1:length(x))
    out <- out + x[i]
  
  ## return 'out'
  return(out)
}
```

```{r speed_check, warning = FALSE}
## speed check
microbenchmark(
  sum(1:1e6), # built-in `sum` function
  sumR(1:1e6), # base-R version
  sumC(1:1e6)  # rcpp version
, times = 20L)
```

As you can see, `sumC` runs more than 40 times faster than `sumR` and, at the 
same time, performs only slightly slower as compared to the highly optimized 
(vectorized) built-in `sum` function. You cannot imagine what's possible with 
**Rcpp** when it comes to more complex operations!

### A short note on the use of `sourceCpp`
For such short operations, the use of `cppFunction` seems reasonable. However, 
we recommend to use `sourceCpp` when it comes to more complex C++ functions. 
Take, for example, the following peace of C++ code that reproduces the built-in 
`cor` function. 

```{r cor_cppFunction, eval = FALSE}
cppFunction('double corC(NumericVector x, NumericVector y) {
  int nx = x.size(), ny = y.size();
  
  if (nx != ny) stop("Input vectors must have equal length!");
  
  double sum_x = sum(x), sum_y = sum(y);
  
  NumericVector xy = x * y;
  NumericVector x_squ = x * x, y_squ = y * y;
  
  double sum_xy = sum(xy);
  double sum_x_squ = sum(x_squ), sum_y_squ = sum(y_squ);
  
  double out = ((nx * sum_xy) - (sum_x * sum_y)) / sqrt((nx * sum_x_squ - pow(sum_x, 2.0)) * (nx * sum_y_squ - pow(sum_y, 2.0)));
  
  return out;
}')
```

Quite confusing, isn't it? Not the least because the inline C++ is not formatted 
properly. Luckily, RStudio comes with a C++ editor that allows you to write 
stand-alone .cpp functions - including code formatting! For that purpose, 
select 'C++ file' from the top-left dropdown menu and paste the code that we 
initially passed as `code` argument to `cppFunction`. 

<center>
  <img src="http://i.imgur.com/nKf0QZH.png" alt="new_cpp" style="width: 125px;"/>
</center>

In order to ensure compatibility with **Rcpp** and make the C++ function 
available in R, we need to add a header to our .cpp file (see below). In the 
end, our .cpp file should look as follows.

```{r engine='Rcpp'}
#include <Rcpp.h>
using namespace Rcpp;

// [[Rcpp::export]]
double corC(NumericVector x, NumericVector y) {
  int nx = x.size(), ny = y.size();
  
  if (nx != ny) stop("Input vectors must have equal length!");
  
  double sum_x = sum(x), sum_y = sum(y);
  
  NumericVector xy = x * y;
  NumericVector x_squ = x * x, y_squ = y * y;
  
  double sum_xy = sum(xy);
  double sum_x_squ = sum(x_squ), sum_y_squ = sum(y_squ);
  
  double out = ((nx * sum_xy) - (sum_x * sum_y)) / sqrt((nx * sum_x_squ - pow(sum_x, 2.0)) * (nx * sum_y_squ - pow(sum_y, 2.0)));
  
  return out;
}
```

Save the file in 'src/corC.cpp' and return to R, then run

```{r cor_sourceCpp}
## source 'corC' function (remember to adjust the path)
sourceCpp("../../../src/corC.cpp")

## correlation of 'carat' and 'price'  
microbenchmark(
  cor(diamonds$carat, diamonds$price), 
  corC(diamonds$carat, diamonds$price) 
, times = 20L)
```

Note that, again, `corC` performs only slightly slower than the built-in `cor` 
function. Just imagine the speed gain as compared to a possible `corR` function!